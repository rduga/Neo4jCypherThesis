%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Background}

\section{NoSQL databases}

\subsection{Neo4j graph database}

Neo4j is the most famous graph database system which is subset of NoSQL databases - databases which
offer more expresiveness than the classic SQL databases. The graph database is consisted of nodes
and relationships which gives us the power to query and update more complex expressions than in the
classic table database approach and gives us helpful graph functions like function for
searching shortest path and so. We chose this system because this system offers in addition to
classical java api approach also the DSL approach - Cypher DSL language which gives us the more
powerful tool to express what we want to process.

\subsection{Neo4j Cypher query language}
	
Cypher is a declarative domain specific query language for Neo4j graph database. It offers high
expressivity and efficient querying and updating of the graph in this database. It is designed both
for developers and for domain exprerts, so the syntax of the language is easy to understand.

\subsubsection{Syntax of Cypher}

To understand the principles and problems of design and implementation of Neo4jCypher (Cypher
implementation in MPS language workbench) we provide you the short overview of Cypher syntax.

Cypher query language is composed of these basic clauses:

\begin{itemize}
  \item \texttt{START} - specifies starting inputs
  \item \texttt{MATCH} - specifies pattern to match from starting nodes
  \item \texttt{WHERE} - next filtering of matched nodes
  \item \texttt{CREATE} - creates nodes, relationships
  \item \texttt{DELETE} - deletes nodes, relationships
  \item \texttt{SET} - updates nodes, relationships
  \item \texttt{RETURN} - returns nodes, relationships, etc.
\end{itemize}

Now we give some examples of queries with explanation what they do:

Read-Only Query:
\lstset{language=SQL}
\begin{lstlisting}
START
[MATCH]
[WHERE]
RETURN [ORDER BY] [SKIP] [LIMIT]
\end{lstlisting}

Write-Only Query:
\begin{lstlisting}
CREATE [UNIQUE]*
[SET|DELETE|FOREACH]*
[RETURN [ORDER BY] [SKIP] [LIMIT]]
\end{lstlisting}  


Read-Write Query:
\begin{lstlisting}
START
[MATCH]
[WHERE]
[CREATE [UNIQUE]]*
[SET|DELETE|FOREACH]*
[RETURN [ORDER BY] [SKIP] [LIMIT]]
\end{lstlisting}
	
%popsat jazyk Cypher (syntax, semantika, priklady, atd)

\section{Domain Specific Languages}

	\subsection{Neo4jCypher DSL}



\section{Language Workbenches}

	\subsection{How to define DSL in MPS}



\section{MPS Language Workbench}

	\subsection{How to Define DSL in MPS}

		\subsubsection{Structure DSL}
		\subsubsection{Editor DSL}
		\subsubsection{Constraints DSL}
		\subsubsection{Typesystem DSL}
		\subsubsection{Intensions and Other Parts}

	\subsection{MPS Pros and Cons}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Design of Neo4jCypher}

\section{Problem analysis}

\section{Design decisions}

\subsection{Projection editor}

MPS Projection editor is a base approach of MPS to editing language. It differs from pure textual
editors in these points:

\begin{itemize}
  \item Unparsable editor notation - editor is composed of cells, every cell represents some node of
  the abstract syntax tree (AST)
  \item Possible switching among multiple notations using alternative editors, where every editor
  can show the AST in different way
  \item Combine notations from different authors and be extensible. It is possible to extend MPS
  languages, compose them and so on
\end{itemize}

\subsection{Text-like editor}

\subsection{Graphical extensions}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Implementation details of Neo4jCypher language}

\section{Patterns}

\section{References}

\section{Integration into BaseLanguage}

MPS has a big advantage that we not only can design the new language and create the full ide
support for this language but also we can integrate this language into some existing language,
extend it and provide the way to execute our code with possibility to debug our code.

We chose these 4 steps, where each next step integrates the Neo4jCypher language more closely into
its BaseLanguage:

\begin{itemize}
  \item Design Neo4jCypher queries in Query Sheet editor - editor with full ide support:
  	\begin{itemize}
  	  \item code completition with correct reference visibility and full cypher function list
  	  \item intensions for query transformation, parts of query grouping, relationship
  	  type conversion, properties definition
  	  \item identifier uniquiness checking
  	  \item items type checking where necessary
  	\end{itemize} 
  \item Generation of MPCypher query into BaseLanguage string type - this approach provides us
  easy creation of query with full ide editor support. The next query manipulation depends on user's
  will. User can store this query or execute it using Neo4j Execution Engine from Neo4j java
  library.
  \item Using CypherExecutor object which adds us easy access to execution of Neo4jCypher query
  without need of implementation any further code from Neo4j java library. This approach tries to
  provide very easy way to query the database without need to know any king of Cypher java
  interface.
\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluation}

MPS platform is a robust tool for creating DSL languages


\section{Experience with MPS}

\section{MPS Contribution in DSL languages}

% Pros&Cons

\section{MPS Contribution in NoSQL Domain}

\section{Related work}
		
\section{Case Study}

% What to study in the future, next ideas of the work, improvements







